# 防腐保温智慧平台开发规范文档

## 1. 代码规范

### 1.1 Python代码规范 (后端)

#### 1.1.1 基本规范
- 遵循 PEP 8 代码风格指南
- 使用 4 个空格进行缩进，不使用 Tab
- 行长度限制为 88 字符
- 使用 Black 进行代码格式化
- 使用 isort 进行导入排序

#### 1.1.2 命名规范
```python
# 变量和函数名：小写字母+下划线
user_name = "张三"
def get_user_info():
    pass

# 类名：大驼峰命名
class UserManager:
    pass

# 常量：全大写+下划线
MAX_FILE_SIZE = 20 * 1024 * 1024

# 私有方法：前缀下划线
def _internal_method():
    pass
```

#### 1.1.3 文档字符串规范
```python
def create_product(product_data: dict) -> dict:
    """
    创建产品信息
    
    Args:
        product_data (dict): 产品数据字典
            - product_name (str): 产品名称
            - product_type (str): 产品类型
            - technical_params (dict): 技术参数
    
    Returns:
        dict: 创建结果
            - product_id (str): 产品ID
            - status (str): 创建状态
    
    Raises:
        ValidationError: 数据验证失败
        DatabaseError: 数据库操作失败
    
    Example:
        >>> product_data = {
        ...     "product_name": "防腐涂料",
        ...     "product_type": "coating"
        ... }
        >>> result = create_product(product_data)
        >>> print(result['product_id'])
        PROD-20240827-001
    """
    pass
```

### 1.2 JavaScript代码规范 (前端)

#### 1.2.1 基本规范
- 使用 ESLint + Prettier 进行代码检查和格式化
- 使用 2 个空格进行缩进
- 字符串优先使用单引号
- 使用分号结束语句

#### 1.2.2 Vue 3 组合式API规范
```javascript
<script setup>
// 1. 导入顺序：Vue相关 -> 第三方库 -> 本地模块
import { ref, reactive, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessage } from 'element-plus'
import { userAPI } from '@/api/user'
import { useAuthStore } from '@/stores/auth'

// 2. 响应式数据定义
const loading = ref(false)
const userForm = reactive({
  username: '',
  email: ''
})

// 3. 计算属性
const isFormValid = computed(() => {
  return userForm.username && userForm.email
})

// 4. 方法定义
const handleSubmit = async () => {
  try {
    loading.value = true
    const result = await userAPI.createUser(userForm)
    ElMessage.success('创建成功')
  } catch (error) {
    ElMessage.error(error.message)
  } finally {
    loading.value = false
  }
}

// 5. 生命周期钩子
onMounted(() => {
  // 初始化逻辑
})
</script>
```

#### 1.2.3 组件命名规范
```javascript
// 组件文件名：大驼峰命名
ProductCard.vue
UserProfile.vue
SearchFilter.vue

// 组件注册名：大驼峰命名
<ProductCard />
<UserProfile />
<SearchFilter />

// Props命名：小驼峰命名
const props = defineProps({
  productInfo: Object,
  isLoading: Boolean,
  maxCount: Number
})

// 事件命名：小驼峰命名
const emit = defineEmits(['updateProduct', 'deleteItem'])
```

## 2. 数据库设计规范

### 2.1 表命名规范
- 表名使用小写字母+下划线，统一前缀 `tx_`
- 表名应该是复数形式，如 `tx_users`, `tx_products`
- 关联表使用两个表名组合，如 `tx_user_permissions`

### 2.2 字段命名规范
```sql
-- 主键统一使用 {表名单数}_id
user_id VARCHAR(32) PRIMARY KEY
product_id VARCHAR(32) PRIMARY KEY

-- 外键使用关联表的主键名
user_id VARCHAR(32) -- 关联tx_users表
supplier_id VARCHAR(32) -- 关联tx_enterprises表

-- 时间字段统一后缀
created_at DATETIME DEFAULT CURRENT_TIMESTAMP
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
deleted_at DATETIME NULL -- 软删除时间

-- 状态字段使用ENUM类型
status ENUM('active', 'inactive', 'pending') DEFAULT 'pending'

-- 金额字段使用DECIMAL
price DECIMAL(10,2) -- 10位数字，2位小数
total_amount DECIMAL(12,2) -- 12位数字，2位小数
```

### 2.3 索引设计规范
```sql
-- 主键自动创建聚簇索引
PRIMARY KEY (user_id)

-- 外键创建普通索引
INDEX idx_user_id (user_id)

-- 查询频繁的字段创建索引
INDEX idx_status (status)
INDEX idx_created_time (created_at)

-- 组合查询创建复合索引
INDEX idx_type_status (product_type, status)
INDEX idx_region (province, city, district)

-- 全文搜索创建FULLTEXT索引
FULLTEXT INDEX idx_search (product_name, description)
```

## 3. API设计规范

### 3.1 RESTful API规范

#### 3.1.1 URL设计规范
```
# 资源命名使用复数名词
GET    /api/v1/products          # 获取产品列表
POST   /api/v1/products          # 创建产品
GET    /api/v1/products/{id}     # 获取单个产品
PUT    /api/v1/products/{id}     # 更新产品
DELETE /api/v1/products/{id}     # 删除产品

# 嵌套资源
GET    /api/v1/suppliers/{id}/products    # 获取供应商的产品列表
POST   /api/v1/demands/{id}/responses     # 对需求进行响应

# 操作性接口使用动词
POST   /api/v1/products/{id}/publish      # 发布产品
POST   /api/v1/orders/{id}/cancel        # 取消订单
POST   /api/v1/users/login               # 用户登录
```

#### 3.1.2 HTTP状态码使用
```python
# 成功响应
200 OK          # 请求成功
201 Created     # 资源创建成功
204 No Content  # 删除成功

# 客户端错误
400 Bad Request          # 请求参数错误
401 Unauthorized         # 未授权
403 Forbidden           # 权限不足
404 Not Found           # 资源不存在
422 Unprocessable Entity # 数据验证失败

# 服务器错误
500 Internal Server Error # 服务器内部错误
502 Bad Gateway          # 网关错误
503 Service Unavailable  # 服务不可用
```

### 3.2 请求响应格式规范

#### 3.2.1 统一响应格式
```python
# utils/response.py
from rest_framework.response import Response
from datetime import datetime
import uuid

def success_response(data=None, message="success", code=200):
    """成功响应格式"""
    return Response({
        "code": code,
        "message": message,
        "data": data,
        "timestamp": datetime.now().isoformat(),
        "request_id": str(uuid.uuid4())
    }, status=code)

def error_response(message, code=400, errors=None):
    """错误响应格式"""
    response_data = {
        "code": code,
        "message": message,
        "timestamp": datetime.now().isoformat(),
        "request_id": str(uuid.uuid4())
    }
    
    if errors:
        response_data["errors"] = errors
    
    return Response(response_data, status=code)
```

#### 3.2.2 分页响应格式
```python
# utils/pagination.py
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response

class CustomPageNumberPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100
    
    def get_paginated_response(self, data):
        return Response({
            'code': 200,
            'message': 'success',
            'data': {
                'results': data,
                'pagination': {
                    'page': self.page.number,
                    'page_size': self.page.paginator.per_page,
                    'total': self.page.paginator.count,
                    'total_pages': self.page.paginator.num_pages,
                    'has_next': self.page.has_next(),
                    'has_previous': self.page.has_previous()
                }
            },
            'timestamp': datetime.now().isoformat()
        })
```

## 4. 安全开发规范

### 4.1 输入验证
```python
# 使用Django REST Framework序列化器进行数据验证
from rest_framework import serializers

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'
    
    def validate_product_name(self, value):
        """产品名称验证"""
        if len(value) < 2:
            raise serializers.ValidationError("产品名称至少2个字符")
        if len(value) > 50:
            raise serializers.ValidationError("产品名称不能超过50个字符")
        return value
    
    def validate_unit_price(self, value):
        """价格验证"""
        if value <= 0:
            raise serializers.ValidationError("价格必须大于0")
        if value > 999999.99:
            raise serializers.ValidationError("价格不能超过999999.99")
        return value
```

### 4.2 权限控制
```python
# utils/permissions.py
from rest_framework.permissions import BasePermission

class IsEnterpriseUser(BasePermission):
    """企业用户权限"""
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and 
            request.user.user_type == 'enterprise'
        )

class IsSupplier(BasePermission):
    """供应商权限"""
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and
            request.user.user_type == 'enterprise' and
            hasattr(request.user, 'enterprise') and
            request.user.enterprise.company_type == 'supplier'
        )

class IsOwnerOrReadOnly(BasePermission):
    """所有者权限或只读"""
    def has_object_permission(self, request, view, obj):
        # 读权限对所有人开放
        if request.method in ['GET', 'HEAD', 'OPTIONS']:
            return True
        
        # 写权限只对所有者开放
        return obj.user == request.user
```

### 4.3 数据加密
```python
# utils/encryption.py
from cryptography.fernet import Fernet
from django.conf import settings
import base64

class DataEncryption:
    """数据加密工具类"""
    
    def __init__(self):
        self.key = settings.ENCRYPTION_KEY.encode()
        self.cipher_suite = Fernet(self.key)
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        if not data:
            return data
        encrypted_data = self.cipher_suite.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        if not encrypted_data:
            return encrypted_data
        try:
            decoded_data = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = self.cipher_suite.decrypt(decoded_data)
            return decrypted_data.decode()
        except Exception:
            return None

# 在模型中使用
class Enterprise(models.Model):
    # 敏感字段加密存储
    business_license_encrypted = models.TextField()
    
    @property
    def business_license(self):
        encryption = DataEncryption()
        return encryption.decrypt(self.business_license_encrypted)
    
    @business_license.setter
    def business_license(self, value):
        encryption = DataEncryption()
        self.business_license_encrypted = encryption.encrypt(value)
```

## 5. 测试规范

### 5.1 单元测试规范

#### 5.1.1 测试文件组织
```
apps/
├── authentication/
│   ├── tests/
│   │   ├── __init__.py
│   │   ├── test_models.py      # 模型测试
│   │   ├── test_views.py       # 视图测试
│   │   ├── test_serializers.py # 序列化器测试
│   │   └── test_utils.py       # 工具函数测试
```

#### 5.1.2 测试用例编写规范
```python
# apps/authentication/tests/test_views.py
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.auth import get_user_model

User = get_user_model()

class UserRegistrationTestCase(APITestCase):
    """用户注册测试用例"""
    
    def setUp(self):
        """测试前置条件"""
        self.registration_url = reverse('auth:register')
        self.valid_data = {
            'username': 'testuser',
            'password': 'testpass123',
            'email': 'test@example.com',
            'phone': '13800138000',
            'user_type': 'enterprise',
            'real_name': '测试用户',
            'verification_code': '123456'
        }
    
    def test_successful_registration(self):
        """测试成功注册"""
        # 模拟验证码
        from django.core.cache import cache
        cache.set('sms_code_13800138000', '123456', 300)
        
        response = self.client.post(self.registration_url, self.valid_data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['code'], 200)
        self.assertTrue(User.objects.filter(username='testuser').exists())
    
    def test_registration_with_invalid_phone(self):
        """测试无效手机号注册"""
        invalid_data = self.valid_data.copy()
        invalid_data['phone'] = '1380013800'  # 无效手机号
        
        response = self.client.post(self.registration_url, invalid_data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('phone', response.data.get('errors', {}))
    
    def test_registration_with_duplicate_username(self):
        """测试重复用户名注册"""
        # 创建已存在用户
        User.objects.create_user(username='testuser', email='existing@example.com')
        
        response = self.client.post(self.registration_url, self.valid_data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
```

### 5.2 集成测试规范
```python
# tests/integration/test_product_workflow.py
from django.test import TransactionTestCase
from rest_framework.test import APIClient
from django.contrib.auth import get_user_model

class ProductWorkflowTestCase(TransactionTestCase):
    """产品完整流程集成测试"""
    
    def setUp(self):
        self.client = APIClient()
        self.supplier_user = self.create_supplier_user()
        self.buyer_user = self.create_buyer_user()
    
    def test_complete_product_workflow(self):
        """测试完整的产品发布到采购流程"""
        # 1. 供应商登录
        self.client.force_authenticate(user=self.supplier_user)
        
        # 2. 发布产品
        product_data = {
            'product_name': '测试防腐涂料',
            'product_type': 'coating',
            'unit_price': 6500.00
        }
        response = self.client.post('/api/v1/info/supply', product_data)
        self.assertEqual(response.status_code, 200)
        product_id = response.data['data']['product_id']
        
        # 3. 采购方登录
        self.client.force_authenticate(user=self.buyer_user)
        
        # 4. 搜索产品
        response = self.client.get('/api/v1/search/multi-dimension', {
            'keyword': '防腐涂料'
        })
        self.assertEqual(response.status_code, 200)
        self.assertGreater(len(response.data['data']['results']), 0)
        
        # 5. 发起询价
        inquiry_data = {
            'product_id': product_id,
            'quantity': 100,
            'message': '请报价'
        }
        response = self.client.post('/api/v1/communication/inquiry', inquiry_data)
        self.assertEqual(response.status_code, 200)
```

## 6. Git工作流规范

### 6.1 分支管理规范
```
main                    # 主分支，生产环境代码
├── develop            # 开发分支，集成最新功能
├── feature/user-auth  # 功能分支，开发具体功能
├── feature/product-mgmt
├── hotfix/fix-login   # 热修复分支，修复紧急问题
└── release/v1.0.0     # 发布分支，准备发布版本
```

### 6.2 提交信息规范
```bash
# 提交信息格式：<type>(<scope>): <subject>

# type类型：
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式调整
refactor: 代码重构
test:     测试相关
chore:    构建工具、依赖更新

# 示例：
git commit -m "feat(auth): 添加用户注册功能"
git commit -m "fix(product): 修复产品搜索分页问题"
git commit -m "docs(api): 更新API接口文档"
```

### 6.3 代码审查规范
- 所有功能分支合并到develop前必须经过代码审查
- 审查内容包括：代码质量、安全性、性能、测试覆盖率
- 至少需要1个其他开发者的审查通过
- 自动化测试必须全部通过

## 7. 性能优化规范

### 7.1 数据库查询优化
```python
# 使用select_related减少数据库查询
products = Product.objects.select_related('supplier').all()

# 使用prefetch_related优化多对多查询
users = User.objects.prefetch_related('permissions').all()

# 使用only()限制查询字段
products = Product.objects.only('id', 'name', 'price').all()

# 使用exists()检查存在性
if Product.objects.filter(name='test').exists():
    pass

# 批量操作使用bulk_create/bulk_update
Product.objects.bulk_create([
    Product(name='产品1', price=100),
    Product(name='产品2', price=200)
])
```

### 7.2 缓存使用规范
```python
# 使用Redis缓存热点数据
from django.core.cache import cache

def get_hot_products():
    """获取热门产品（缓存30分钟）"""
    cache_key = 'hot_products'
    products = cache.get(cache_key)
    
    if products is None:
        products = Product.objects.filter(
            status='published'
        ).order_by('-view_count')[:10]
        cache.set(cache_key, products, 1800)  # 30分钟
    
    return products

# 缓存用户权限信息
def get_user_permissions(user_id):
    cache_key = f'user_permissions_{user_id}'
    permissions = cache.get(cache_key)
    
    if permissions is None:
        permissions = UserPermission.objects.filter(
            user_id=user_id
        ).values_list('permission_code', flat=True)
        cache.set(cache_key, list(permissions), 3600)  # 1小时
    
    return permissions
```

## 8. 错误处理规范

### 8.1 异常处理
```python
# utils/exceptions.py
from rest_framework.views import exception_handler
from rest_framework.response import Response
import logging

logger = logging.getLogger(__name__)

def custom_exception_handler(exc, context):
    """自定义异常处理器"""
    response = exception_handler(exc, context)
    
    if response is not None:
        # 记录错误日志
        logger.error(f"API Error: {exc}", extra={
            'request': context['request'],
            'view': context['view']
        })
        
        # 自定义错误响应格式
        custom_response_data = {
            'code': response.status_code,
            'message': '请求处理失败',
            'error_detail': response.data,
            'timestamp': datetime.now().isoformat()
        }
        response.data = custom_response_data
    
    return response

# 在视图中使用try-catch
from utils.exceptions import BusinessException

class ProductViewSet(viewsets.ModelViewSet):
    def create(self, request):
        try:
            # 业务逻辑
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)
            product = serializer.save()
            
            return success_response({
                'product_id': product.product_id
            }, message='产品创建成功')
            
        except ValidationError as e:
            return error_response('数据验证失败', code=422, errors=e.detail)
        except BusinessException as e:
            return error_response(str(e), code=400)
        except Exception as e:
            logger.exception("产品创建失败")
            return error_response('系统错误，请稍后重试', code=500)
```

## 9. 日志记录规范

### 9.1 日志级别使用
```python
import logging

logger = logging.getLogger(__name__)

# DEBUG: 详细的调试信息
logger.debug(f"用户 {user_id} 开始搜索产品，关键词: {keyword}")

# INFO: 一般信息记录
logger.info(f"用户 {user_id} 成功创建产品 {product_id}")

# WARNING: 警告信息
logger.warning(f"用户 {user_id} 尝试访问无权限资源 {resource_id}")

# ERROR: 错误信息
logger.error(f"产品创建失败，用户: {user_id}, 错误: {str(e)}")

# CRITICAL: 严重错误
logger.critical(f"数据库连接失败: {str(e)}")
```

### 9.2 业务日志记录
```python
# utils/audit_log.py
from django.db import models

class AuditLog(models.Model):
    """审计日志模型"""
    user_id = models.CharField(max_length=32)
    action = models.CharField(max_length=50)  # 操作类型
    resource_type = models.CharField(max_length=50)  # 资源类型
    resource_id = models.CharField(max_length=32)  # 资源ID
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField()
    request_data = models.JSONField(null=True)  # 请求数据
    response_code = models.IntegerField()  # 响应状态码
    created_at = models.DateTimeField(auto_now_add=True)

def log_user_action(user, action, resource_type, resource_id, request, response_code=200):
    """记录用户操作日志"""
    AuditLog.objects.create(
        user_id=user.user_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        ip_address=get_client_ip(request),
        user_agent=request.META.get('HTTP_USER_AGENT', ''),
        request_data=request.data if hasattr(request, 'data') else None,
        response_code=response_code
    )
```
